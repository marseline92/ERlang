---Генератори списків---

За допомогою генераторів списків створіть список всіх чисел від 0 до 10,
які діляться на 3 без залишку (тобто [3,6,9]).


[X || X <- lists:seq(0, 10), X rem 3 == 0, X >= 3].

За допомогою генераторів списків приберіть всі елементи поліморфного списка, які не є цілими числами. 
Наприклад, список [1, hello,100, boo," boo", 9] буде перетворено в список [1, 100, 9].


[X || X <- [1,hello,100,boo,"boo",9], is_integer(X)].

За допомогою генераторів списків побудуйте список, 
який є пересіченям двох даних списків (як [4,5] для [1,2,3,4,5] і [4,5,6,7,8]).


[X || X <- [1,2,3,4,5], Y <- [4,5,6,7,8], X==Y]. 

За допомогою генераторів списків побудуйте симетричну різницю двох
данних списків (як [1,2,3,6,7,8] для [1,2,3,4,5] та [4,5,6,7,8]).


[X || X <- [1,2,3,4,5], not lists:member(X, [4,5,6,7,8])] ++ [X || X <- [4,5,6,7,8], not lists:member(X, [1,2,3,4,5])].

---Функція zip---

Визначте функцію zip, яка перетворює пару списків у список пар:
zip([l,2],[3,4,5]) = [{1,3}{2,4}]

lists:zip([1,2], [3,4,5]).
АБО
L1=[1,2].
L2=[3,4,5].
lists:zip2(L1, L2).
АБО
zip(_, []) ->
  [];
zip([], _) ->
  [];
zip([X|Xs], [Y|Ys]]) ->
  [{X,Y}|zip(Xs,Ys)].

Визначте функцію zipWith, яка застосовує бінарну функцію до елементів
двох списків і повертає список результатів.
add(X,Y) -> X+Y.
zipWith(Add, [1,2], [3,4,5]) = [4,6]

lists:zipwith(fun(X, Y) -> X+Y end, [1,2,3], [4,5,6]).
АБО
zipwith(Func, L1, L2) ->
  [Func(X, Y) || {X, Y} <- zip(L1, L2)].
